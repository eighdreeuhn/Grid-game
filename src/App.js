import React, { useState } from "react";
import Tile from "./Tile";
import './App.css';

function App() {
  //tiles starts as an empty array with setState initialized to update it 
  const [tiles, setTiles] = useState([]);
  let winning = document.getElementsByClassName("game-box");
  //generateBoard builds a new game board by generating an rng based on the leangth of 
  //array of values left to be assigned, gets the value stored there and assigns it
  // a row and a column generated by two nested for loops
  const generateBoard = () => {
    let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
    let newBoard = []
    let newTile
    for (let row = 1; row <= 5; row++) {
      for (let column = 1; column <= 5; column++) {
        let newTileIndex = Math.floor(Math.random() * values.length);
        //generate a random rgb color
        const red = Math.floor(Math.random() * 100)
        const blue = Math.floor(Math.random() * 100)
        const green = Math.floor(Math.random() * 100)
        //create a new object with the values created
        if (row === 5 && column === 5) {
          newTile = {
            number: "blank",
            row: row,
            column: column,
            color: `rgb(${red}, ${blue}, ${green})`,
          }
        } else {
          newTile = {
            number: values[newTileIndex],
            row: row,
            column: column,
            color: `rgb(${red}, ${blue}, ${green})`,
          }
        }
        //remove the assigned value from the values array
        values.splice(newTileIndex, 1);
        //push the new object into the newBoard array
        newBoard.push(newTile);
      }
    }
    //update the tiles array with newBoard array
    setTiles(newBoard);
  }
  
  const celebration = () => {
    cons  ole.log(winning)
    console.log('winner')
    winning[0].classList.toggle('winner')
  }
  
  const checkWinner = (board) => {
    let winner = false
    let i = 0;
    while (board[i].number === i + 1) {
      winner = true;
      i++;
      if (i === 24 && winner) {
        celebration();
      }
    }
    
  }
  
  //handle the case blank & target are in the same row
  const rowSwitch = (activeIndex, blankIndex, direction) => {
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.column;
    let activeTarget = activeCopy.column;
    let nextCopy;
    while (tilesCopy[blankIndex + direction].column !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + direction];
      nextCopy.column = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.column += direction;
      blankIndex += direction;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.column = activeCopy.column;
    tilesCopy.splice(activeIndex, 1, blankCopy);
    activeCopy.column = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy);
    setTiles(tilesCopy);
  }
  //handle the case blank & target are in the same column
  const columnSwitch = (activeIndex, blankIndex, direction) => {
    const rowJump = direction * 5;
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.row;
    let activeTarget = activeCopy.row;
    let nextCopy;
    while (tilesCopy[blankIndex + rowJump].row !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + rowJump];
      nextCopy.row = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.row += direction;
      blankIndex += rowJump;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.row = activeCopy.row;
    tilesCopy.splice(activeIndex, 1, blankCopy)
    activeCopy.row = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy)
    setTiles(tilesCopy);
  }
  
  const handleSwitch = (e) => {
    const activeIndex = tiles.findIndex(tile => tile.number === parseInt(e.target.id));
    const blankIndex = tiles.findIndex(tile => tile.number === "blank");
    const activeTile = tiles[activeIndex];
    const blankTile = tiles[blankIndex];
    let direction;
    if (activeTile.number !== "blank" && activeTile.row === blankTile.row) {
      activeTile.column - blankTile.column < 0 ? direction = -1 : direction = 1;
      rowSwitch(activeIndex, blankIndex, direction);
    } else if (activeTile.number !== "blank" && activeTile.column === blankTile.column) {
      activeTile.row - blankTile.row < 0 ? direction = -1 : direction = 1;
      columnSwitch(activeIndex, blankIndex, direction);
    }
  }
  
  if (tiles.length === 25) {
    checkWinner(tiles)
  }
  
  //create the tile divs with the tiles array and store them in board
  const board = tiles.map((tile, index) => {
    return (
      <Tile
      number={tile.number}
      row={tile.row}
      column={tile.column}
      color={tile.color}
      key={index}
      onClick={handleSwitch}
      className="tile"
      />
      )
    })
    
    return (
      <div className="App">
      <header>
        <h3>Welcome to Number Tiles!
          Click Play to get started</h3>
      </header>
      <section className="main">
        <button onClick={() => {
          if (winning[0].classList.contains('winner')) {winning[0].classList.toggle('winner')}
          generateBoard();
        }}>Play/Reset</button>
        <div className="game-box">
          {board}
        </div>
      </section>
    </div>
  )
}

export default App;