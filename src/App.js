import React, { useState } from "react";
import Tile from "./Tile";
import './App.css';

function App() {
  //tiles starts as an empty array with setState initialized to update it 
  const [tiles, setTiles] = useState([]);
  const huh = setTiles;
  console.log(huh);
  let winning = document.getElementsByClassName("game-box");
  console.log(winning);
  //generateBoard builds a new game board by generating an rng based on the leangth of 
  //array of values left to be assigned, gets the value stored there and assigns it
  // a row and a column generated by two nested for loops
  const generateBoard = () => {
    let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, "blank"];
    let newBoard = []
    for (let row = 1; row <= 5; row++) {
      for (let column = 1; column <= 5; column++) {
        let newTileIndex = Math.floor(Math.random() * values.length);
        //generate a random rgb color
        const red = Math.floor(Math.random() * 100)
        const blue = Math.floor(Math.random() * 100)
        const green = Math.floor(Math.random() * 100)
        //create a new object with the values created
        let newTile = {
          number: values[newTileIndex],
          row: row,
          column: column,
          color: `rgb(${red}, ${blue}, ${green})`,
        };
        //remove the assigned value from the values array
        values.splice(newTileIndex, 1);
        //push the new object into the newBoard array
        newBoard.push(newTile);
      }
    }
    //update the tiles array with newBoard array
    setTiles(newBoard);
  }

  const celebration = () => {
    console.log("Too lazy to do CSS atm, but good job anyway...");
    winning.getAttribute.classList()

  }

  const checkWinner = (board) => {
    let winner = false
    let i = 0;
    while (board[i].number === i + 1) {
      winner = true;
      console.log("yup...");
      i++;
      if (i === 23 && winner === true) {
        celebration();
      }
    }

  }

  //handle the case blank & target are in the same row
  const rowSwitch = (activeIndex, blankIndex, direction) => {
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.column;
    let activeTarget = activeCopy.column;
    let nextCopy;
    while (tilesCopy[blankIndex + direction].column !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + direction];
      nextCopy.column = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.column += direction;
      blankIndex += direction;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.column = activeCopy.column;
    tilesCopy.splice(activeIndex, 1, blankCopy);
    activeCopy.column = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy);
    checkWinner(tiles);
    setTiles(tilesCopy);
  }
  //handle the case blank & target are in the same column
  const columnSwitch = (activeIndex, blankIndex, direction) => {
    const rowJump = direction * 5;
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.row;
    let activeTarget = activeCopy.row;
    let nextCopy;
    while (tilesCopy[blankIndex + rowJump].row !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + rowJump];
      nextCopy.row = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.row += direction;
      blankIndex += rowJump;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.row = activeCopy.row;
    tilesCopy.splice(activeIndex, 1, blankCopy)
    activeCopy.row = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy)
    checkWinner(tiles)
    setTiles(tilesCopy);
  }

  const handleSwitch = (e) => {
    const activeIndex = tiles.findIndex(tile => tile.number === parseInt(e.target.id));
    const blankIndex = tiles.findIndex(tile => tile.number === "blank");
    const activeTile = tiles[activeIndex];
    const blankTile = tiles[blankIndex];
    let direction;
    if (activeTile.number !== "blank" && activeTile.row === blankTile.row) {
      activeTile.column - blankTile.column < 0 ? direction = -1 : direction = 1;
      rowSwitch(activeIndex, blankIndex, direction);
    } else if (activeTile.number !== "blank" && activeTile.column === blankTile.column) {
      activeTile.row - blankTile.row < 0 ? direction = -1 : direction = 1;
      columnSwitch(activeIndex, blankIndex, direction);
    } else {
    }
    checkWinner(tiles)
  }

  //create the tile divs with the tiles array and store them in board
  const board = tiles.map((tile, index) => {
    return (
      <Tile
        number={tile.number}
        row={tile.row}
        column={tile.column}
        color={tile.color}
        key={index}
        onClick={handleSwitch}
        className="tile"
      />
    )
  })
  //return the physical board

  // celebration();

  return (
    <div className="App">
      <header>
        <h3>Welcome to Number Tiles!
          Click Play to get started</h3>
      </header>
      <section className="main">
        <button onClick={() => {
          generateBoard();
        }}>Play/Reset</button>
        <div className="game-box">
          {board}
        </div>
      </section>
    </div>
  )
}

export default App;