import React, { useState } from "react";
import Welcome from "./Components/Welcome";
import Tile from "./Components/Tile";
import Winner from "./Components/Winner";
import './App.css';

function App() {
  //tiles starts as an empty array with setState initialized to update it 
  const [tiles, setTiles] = useState([]);
  const [gameState, setGameState] = useState('welcome')
  //generateBoard builds a new game board by generating an rng based on the leangth of 
  //array of values left to be assigned, gets the value stored there and assigns it
  // a row and a column generated by two nested for loops

  //Checks the inversion of the board and calls generateBoard again if the given board is unsolvable.
  //For a board of size 5 X 5 (n % 2 === 1) only a board with an even number of inversions can be solved.

  const isSolvable = (board) => {
    console.log(board)
    let inversions = 0
    for (let i = 0; i < 23; i++) {
      for (let j = 1; j < 24; j++) {
        if (board[i].number > board[j].number) {
          inversions++
        }
      }
    }
    console.log(inversions)
    return (inversions % 2) === 0
  }

  const generateBoard = () => {
    setGameState('unsolved')
    let values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24];
    let newBoard = []
    let newTile
    for (let row = 1; row <= 5; row++) {
      for (let column = 1; column <= 5; column++) {
        let newTileIndex = Math.floor(Math.random() * values.length);
        //generate a random rgb color
        const red = Math.floor(Math.random() * 100)
        const blue = Math.floor(Math.random() * 100)
        const green = Math.floor(Math.random() * 100)
        //create a new object with the values created
        if (row === 5 && column === 5) {
          newTile = {
            number: "blank",
            row: row,
            column: column,
            color: `rgb(${red}, ${blue}, ${green})`,
          }
        } else {
          newTile = {
            number: values[newTileIndex],
            row: row,
            column: column,
            color: `rgb(${red}, ${blue}, ${green})`,
          }
        }
        //remove the assigned value from the values array
        values.splice(newTileIndex, 1);
        //push the new object into the newBoard array
        newBoard.push(newTile);
      }
    }
    //update the tiles array with newBoard array
    isSolvable(newBoard) ?
    setTiles(newBoard) :
    generateBoard()
  }
  
  const checkWinner = (board) => {
    let i = 0;
    while (board[i].number === i + 1) {
      i++;
      if (i === 24 && gameState !== 'winner') {
        setGameState('winner')
      }
    }
    
  }
  
  //handle the case blank & target are in the same row
  const rowSwitch = (activeIndex, blankIndex, direction) => {
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.column;
    let activeTarget = activeCopy.column;
    let nextCopy;
    while (tilesCopy[blankIndex + direction].column !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + direction];
      nextCopy.column = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.column += direction;
      blankIndex += direction;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.column = activeCopy.column;
    tilesCopy.splice(activeIndex, 1, blankCopy);
    activeCopy.column = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy);
    setTiles(tilesCopy);
  }
  //handle the case blank & target are in the same column
  const columnSwitch = (activeIndex, blankIndex, direction) => {
    const rowJump = direction * 5;
    let tilesCopy = [...tiles];
    let activeCopy = tilesCopy[activeIndex];
    let blankCopy = tilesCopy[blankIndex];
    let blankTarget = blankCopy.row;
    let activeTarget = activeCopy.row;
    let nextCopy;
    while (tilesCopy[blankIndex + rowJump].row !== activeTarget) {
      nextCopy = tilesCopy[blankIndex + rowJump];
      nextCopy.row = blankTarget;
      tilesCopy.splice(blankIndex, 1, nextCopy);
      blankCopy.row += direction;
      blankIndex += rowJump;
      blankTarget += direction;
      tilesCopy.splice(blankIndex, 1, blankCopy)
      setTiles(tilesCopy);
    }
    blankCopy.row = activeCopy.row;
    tilesCopy.splice(activeIndex, 1, blankCopy)
    activeCopy.row = blankTarget;
    tilesCopy.splice(blankIndex, 1, activeCopy)
    setTiles(tilesCopy);
  }
  
  const handleSwitch = (e) => {
    const activeIndex = tiles.findIndex(tile => tile.number === parseInt(e.target.id));
    const blankIndex = tiles.findIndex(tile => tile.number === "blank");
    const activeTile = tiles[activeIndex];
    const blankTile = tiles[blankIndex];
    let direction;
    if (activeTile.number !== "blank" && activeTile.row === blankTile.row) {
      activeTile.column - blankTile.column < 0 ? direction = -1 : direction = 1;
      rowSwitch(activeIndex, blankIndex, direction);
    } else if (activeTile.number !== "blank" && activeTile.column === blankTile.column) {
      activeTile.row - blankTile.row < 0 ? direction = -1 : direction = 1;
      columnSwitch(activeIndex, blankIndex, direction);
    }
  }
  
  if (tiles.length === 25) {
    checkWinner(tiles)
  }
  
  //create the tile divs with the tiles array and store them in board
  const board = tiles.map((tile, index) => {
    return (
      <Tile
      number={tile.number}
      row={tile.row}
      column={tile.column}
      color={tile.color}
      key={index}
      onClick={handleSwitch}
      className="tile"
      />
      )
    })
    
    return (
      <div className="App">
      <section className="main">
        <div className={gameState}>
          {gameState === 'welcome' ?
          <Welcome className='welcome' /> :
          gameState === 'unsolved' ?
          board :
          <Winner />}
        </div>
          <button onClick={() => {
            generateBoard();
          }}>Play/Reset</button>
      </section>
    </div>
  )
}

export default App;